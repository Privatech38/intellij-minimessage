{
    parserClass="dev.privatech.plugin.minimessage.parser.MiniMessageParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="MiniMessage"
    psiImplClassSuffix="Impl"
    psiPackage="dev.privatech.plugin.minimessage.psi"
    psiImplPackage="dev.privatech.plugin.minimessage.psi.impl"

    elementTypeHolderClass="dev.privatech.plugin.minimessage.psi.MiniMessageTypes"
    elementTypeClass="dev.privatech.plugin.minimessage.psi.MiniMessageElementType"
    tokenTypeClass="dev.privatech.plugin.minimessage.psi.MiniMessageTokenType"

    psiImplUtilClass="dev.privatech.plugin.minimessage.psi.impl.MiniMessagePsiImplUtil"

    tokens=[
        COLON=":"
        LT="<"
        GT=">"
        SLASH="/"

        // Custom tokens
        PLAIN_TEXT
        TAG_NAME
        CUSTOM_TAG_NAME
        ARGUMENT
        LEGACY_FORMATTING_CODE
        WHITE_SPACE
        ESCAPED_CHAR
        STRING_TEXT
        QUOTATION
    ]
}

root ::= (tag | LEGACY_FORMATTING_CODE | text) *

text ::= PLAIN_TEXT | ESCAPED_CHAR | STRING_TEXT | ARGUMENT

private tag ::= opening_tag | closing_tag

opening_tag    ::= LT tag_name tag_argument * SLASH? GT // Can be self-closing, made like this for simplicity
closing_tag    ::= LT SLASH tag_name GT { pin=2 }

private tag_name ::= TAG_NAME | CUSTOM_TAG_NAME

tag_argument ::= COLON argument_type { pin=1 methods=[getTrimmedArgument normalizeTextRange] }
private argument_type ::= text + | QUOTATION text * QUOTATION