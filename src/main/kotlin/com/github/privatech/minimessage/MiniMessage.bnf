{
    parserClass="com.github.privatech.minimessage.parser.MiniMessageParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="MiniMessage"
    psiImplClassSuffix="Impl"
    psiPackage="com.github.privatech.minimessage.psi"
    psiImplPackage="com.github.privatech.minimessage.psi.impl"

    elementTypeHolderClass="com.github.privatech.minimessage.psi.MiniMessageTypes"
    elementTypeClass="com.github.privatech.minimessage.psi.MiniMessageElementType"
    tokenTypeClass="com.github.privatech.minimessage.psi.MiniMessageTokenType"

    tokens=[
        COLON=":"
        LT="<"
        GT=">"
        SLASH="/"
        ESCAPE='\'

        // Custom tokens
        PLAIN_TEXT
        TAG_NAME
        CUSTOM_TAG_NAME
        ARGUMENT
        STRING
        LEGACY_FORMATTING_CODE
        WHITE_SPACE
    ]
}

root ::= content

private content ::= (possible_tag | LEGACY_FORMATTING_CODE | PLAIN_TEXT) *

private possible_tag ::= ESCAPE LT? | empty_tag | LT+ WHITE_SPACE | tag

private tag ::= self_closing_tag | opening_tag | closing_tag

empty_tag      ::= LT GT { recoverWhile=tag_recovery }
self_closing_tag ::= LT tag_name tag_argument? SLASH GT { recoverWhile=tag_recovery }
opening_tag    ::= LT tag_name tag_argument? GT { recoverWhile=tag_recovery }
closing_tag    ::= LT SLASH tag_name GT { pin=2 recoverWhile=tag_recovery }

private tag_recovery ::= !LT

private tag_name ::= TAG_NAME | CUSTOM_TAG_NAME

tag_argument ::= COLON argument_type tag_argument? { pin=1 }
private argument_type ::= STRING | ARGUMENT
